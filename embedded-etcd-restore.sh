#!/usr/bin/env bash
#Does a restore of local etcd based on snapshot using generated certs or already existing certs in /etc/kubernetets/pki/etcd. Snapshot location(ETCD_SNAPSHOT), restore path(RESTORE_PATH i.e. --data-dir) and what certificates to use for restoring the backup can be controlled. /etc/kubernetes/pki/server.crt is kubeadm generated cert whereas /etc/kubernetes/pki/master.crt - would mean a cert generated by using the gen-certs.sh for a machine named master.

#ETCD_SNAPSHOT=./backups/server-cert.db ETCD_CERT=server ./embedded-etcd-restore.sh 
. utils.sh
  
install_etcdctl

count=0

if [ -d $default_backup_loc ]; then
  count=$(ls $default_backup_loc/*.db | wc -l)
fi
ETCD_CERT=server
ETCD_SNAPSHOT=${ETCD_SNAPSHOT:-$default_backup_loc/snapshot#$count.db}
IP_ADDRESS=$(hostname -i)

count=0
if [ -d $data_dir ]; 
  then
    count=$(find $data_dir/* -maxdepth 0 -type d | wc -l)
  else
    mkdir -p $data_dir
fi

RESTORE_PATH=${RESTORE_PATH:-$data_dir/restore#$count}

prnt  "Would restore from $ETCD_SNAPSHOT at $RESTORE_PATH. Can change restore locations(from/to) by setting the ETCD_SNAPSHOT/RESTORE_PATH environment variables."
read -p "Proceed with restore? " -n 1 -r
if [[ ! $REPLY =~ ^[Yy]$ ]]
then
    err "\nAborted backup restore.\n"
    exit 1
fi
if [ ! -f ${ETCD_SNAPSHOT} ]; then
    err "Snapshot path ${ETCD_SNAPSHOT} does not exists!"
    exit 1
fi

etcdctl snapshot status ${ETCD_SNAPSHOT} || exit_code=$?
if (( exit_code != 0 )) ; 
  then
    err "Status check on the snapshot returned $exit_code. Is the snapshot corrupt?"
    exit $exit_code
  else
    prnt "etcd snapshot ${ETCD_SNAPSHOT} status passed!"
fi

prnt "Restoring at location: ${RESTORE_PATH}"
rm -rf $RESTORE_PATH
rm .token
token=''
gen_token token

ETCDCTL_API=3 etcdctl snapshot restore $ETCD_SNAPSHOT --name=$(hostname) --data-dir=$RESTORE_PATH --initial-advertise-peer-urls=https://${IP_ADDRESS}:2380 --initial-cluster $(hostname)=https://${IP_ADDRESS}:2380 --initial-cluster-token=${token} --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/${ETCD_CERT}.crt --key=/etc/kubernetes/pki/etcd/${ETCD_CERT}.key --endpoints=https://${IP_ADDRESS}:2379

cat vault/kube-apiserver.yaml | base64 -d >  kube.draft
sed -i "s|host_ip|$(hostname -i)|g" kube.draft
sed -i "s|localhost|127.0.0.1|g" kube.draft

cat vault/etcd.yaml | base64 -d >  etcd.draft
sed -i "s|host_ip|$(hostname -i)|g" etcd.draft
sed -i "s|localhost|127.0.0.1|g" etcd.draft
OLD_DATA_DIR=$(cat etcd.draft | grep "\-\-data-dir=")
OLD_DATA_DIR=${OLD_DATA_DIR:17}
sed -i "s|$OLD_DATA_DIR|$RESTORE_PATH|g" etcd.draft

#initial-cluster-token
sed -i '/initial-cluster-token/d' etcd.draft
sed -i "/--client-cert-auth=true/a\    \- --initial-cluster-token=$token" etcd.draft
systemctl stop etcd &> /dev/null
mv etcd.draft /etc/kubernetes/manifests/etcd.yaml
mv kube.draft /etc/kubernetes/manifests/kube-apiserver.yaml
prnt "Post etcd restore - checking kube-system pods..."
rm status-report 2> /dev/null

kubectl -n kube-system get pod | tee status-report

status=$(cat status-report |  awk '{if(NR>1)print}' | awk '{print $3}' | sort -u)
i=3
while [ "$i" -gt 0 ] && [[ ! $status =~ "Running" ]] ; do
  sleep $i
  i=$((i-1))
  rm status-report 
  kubectl -n kube-system get pod | tee status-report
  status=$(cat status-report |  awk '{if(NR>1)print}' | awk '{print $3}' | sort -u)
done

rm status-report

prnt "Snapshot restored"

